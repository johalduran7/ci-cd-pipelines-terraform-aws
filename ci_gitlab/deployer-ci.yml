workflow:
  rules:
    - if: '$CI_COMMIT_BRANCH != "master"'  # Exclude master branch
      # changes:
      #   - app/app_version.txt  # Trigger only if this file changes
      when: always
    - when: never  # Prevents the pipeline from running otherwise

stages:
  - setup
  - validate_version
  - load_env_variables
  - validate_existing_ECR_tags
  - ECR_login
  - build_and_push
  - app_version_to_parameter_store
  - update_asg


variables:
  BIN_DIR: "${CI_PROJECT_DIR}/bin"  # Store binaries in project directory
  DOCKER_HOST: tcp://docker:2375
  DOCKER_TLS_CERTDIR: ""

services:
  - docker:dind 


cache:
  key: "docker-aws-cli-cache"
  paths:
    - ${BIN_DIR}/  
  policy: pull-push


setup:
  stage: setup
  before_script:
    - apt-get update && apt-get install -y unzip curl jq 
    - mkdir -p ${BIN_DIR} && export PATH="${BIN_DIR}:$PATH"
    - if [ ! -f "${BIN_DIR}/aws" ]; then curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip" && unzip awscliv2.zip && ./aws/install --bin-dir ${BIN_DIR} --install-dir ${BIN_DIR}; fi

  script:
    - ls /usr/local/bin/
    - which jq
  cache:
    key: "docker-aws-cli-cache"
    paths:
      - ${BIN_DIR}/  
    policy: pull-push  # Save & restore cache across jobs


validate_version:
  stage: validate_version
  needs: [setup]
  before_script:
  - export PATH="${BIN_DIR}:$PATH"
  script:
    - 'export VERSION=$(cat app/app_version.txt)'
    - 'echo "VERSION: $VERSION"'
    - 'TAG="${CI_COMMIT_REF_NAME}-app-v${VERSION}"'
    - 'echo ${TAG}'
    - 'git fetch --tags'
    - 'git tag'
    - > 
      if ! git fetch --tags || ! git tag | grep -q "^${TAG}$"; then 
        echo "Error: No matching tag ${TAG} found." && exit 1;  
      fi
    - 'echo "TAG=${TAG}" >> variables.env'
    - 'echo "VERSION=${VERSION}" >> variables.env'
    - 'echo "ENVIRONMENT=${CI_COMMIT_REF_NAME}" >> variables.env'

  artifacts:
    paths:
    - variables.env  # Ensure `variables.env` persis
    reports:
      dotenv: variables.env 
  cache:
    key: "docker-aws-cli-cache"
    paths:
      - ${BIN_DIR}/  
    policy: pull-push  

load_env_variables:
  stage: load_env_variables
  needs: [validate_version]
  before_script:
  - export PATH="${BIN_DIR}:$PATH"
  - source variables.env  # Load persisted variable
  script:
    - 'ENVIRONMENT_UPPERCASE=$(echo "${ENVIRONMENT}" | tr "[:lower:]" "[:upper:]")'
    - 'grep "^${ENVIRONMENT_UPPERCASE}_" app/.env | sed -E "s/^${ENVIRONMENT_UPPERCASE}_//" >> variables.env'
    - 'echo "ENVIRONMENT_UPPERCASE: ${ENVIRONMENT_UPPERCASE}"'
    - 'echo "ENVIRONMENT: ${ENVIRONMENT}"'
    - 'echo "TAG: ${TAG}"'
    - 'cat app/asg-config.txt >> variables.env'
    #- 'while read line; do echo "$line" >> variables.env; done < app/asg-config.txt'

  artifacts:
    paths:
      - variables.env  
    reports:
      dotenv: variables.env 
  cache:
    key: "docker-aws-cli-cache"
    paths:
      - ${BIN_DIR}/  
    policy: pull-push  

validate_existing_ECR_tags:
  stage: validate_existing_ECR_tags
  needs: [load_env_variables]
  before_script:
  - export PATH="${BIN_DIR}:$PATH"
  - source variables.env
  script:
    - env
    - 'echo TAG on second stage: ${TAG}'
    - ls -lah
    - 'echo "AWS Region: ${aws_region}"'
    - |
      ECR_REPO_NAME=$(aws ssm get-parameter --region "${aws_region}" \
        --name "/app/${ENVIRONMENT}/ecr_repository_name" \
        --query "Parameter.Value" --output text 2>/dev/null || echo "ParameterNotFound")
      
      if [[ "${ECR_REPO_NAME}" == "ParameterNotFound" ]]; then
        echo "No ECR registry for the app has been created yet. Parameter /app/${ENVIRONMENT}/ecr_repository_name doesn't exist: ${ECR_REPO_NAME}"
        echo "Pipeline ends here since no ECR registry was found"
      else
        tags=$(aws ecr list-images --region ${aws_region} --repository-name ${ECR_REPO_NAME} --query 'imageIds[].imageTag' --output json)
        echo "Checking if the app version exists in the registry ${ECR_REPO_NAME}"

        if echo "${tags}" | jq -e --arg VERSION "${VERSION}" '.[] | select(. == "${VERSION}")' >/dev/null; then
            tag_exists=true
            echo "the tag ${TAG} exists in the registry ${ECR_REPO_NAME}"
            
        else
            tag_exists=false
            echo "the tag ${TAG} does not exist in the registry ${ECR_REPO_NAME}"
        fi

        echo "${tag_exists}"

      fi

      echo "The tag_exists value is: ${tag_exists}"
    
    - 'echo "ECR_REPO_NAME=${ECR_REPO_NAME}" >> variables.env'
    - 'echo "tag_exists=${tag_exists}" >> variables.env'

  artifacts:
    paths:
      - variables.env  
    reports:
      dotenv: variables.env 
  cache:
    key: "docker-aws-cli-cache"
    paths:
      - ${BIN_DIR}/  
    policy: pull-push  

ECR_login:
  stage: ECR_login
  needs: 
    - job: validate_existing_ECR_tags
      artifacts: true
  rules:
    - exists:
        - variables.env
    - if: '$tag_exists == "false"'
  before_script:
  - export PATH="${BIN_DIR}:$PATH"
  - source variables.env
  script:
    - 'AWS_REGISTRY_PASS=$(aws ecr get-login-password --region ${aws_region})'
    - 'AWS_ACCOUNT=$(aws sts get-caller-identity --query Account --output text)'
    - 'ECR_REGISTRY="${AWS_ACCOUNT}.dkr.ecr.${aws_region}.amazonaws.com"'
    - 'echo "AWS_REGISTRY_PASS=${AWS_REGISTRY_PASS}" >> variables.env'
    - 'echo "AWS_ACCOUNT=${AWS_ACCOUNT}" >> variables.env'
    - 'echo "ECR_REGISTRY=${ECR_REGISTRY}" >> variables.env'

  artifacts:
    paths:
      - variables.env  
    reports:
      dotenv: variables.env 
  cache:
    key: "docker-aws-cli-cache"
    paths:
      - ${BIN_DIR}/  
    policy: pull-push  

build_and_push:
  image: docker:latest
  services:
  - docker:dind 
  stage: build_and_push
  needs: 
    - job: ECR_login
      artifacts: true
  # rules:
  #   - exists:
  #       - variables.env
  #   - if: '$tag_exists == "false"'
  before_script:
  - export PATH="${BIN_DIR}:$PATH"
  - source variables.env
  script:
    - 'echo "${AWS_REGISTRY_PASS}" | docker login --username AWS --password-stdin ${AWS_ACCOUNT}.dkr.ecr.${aws_region}.amazonaws.com'
    - 'git fetch --tags'
    - 'git checkout ${TAG}'
    - cd app/src/
    - 'docker build -t ${ECR_REPO_NAME}:${VERSION} .'
    - 'docker tag ${ECR_REPO_NAME}:${VERSION} ${ECR_REGISTRY}/${ECR_REPO_NAME}:${VERSION}'
    - 'docker push ${ECR_REGISTRY}/${ECR_REPO_NAME}:${VERSION}'
    
  artifacts:
    paths:
      - variables.env  
    reports:
      dotenv: variables.env 
  cache:
    key: "docker-aws-cli-cache"
    paths:
      - ${BIN_DIR}/  
    policy: pull-push  

app_version_to_parameter_store:
  stage: app_version_to_parameter_store
  needs: [build_and_push]
  before_script:
  - export PATH="${BIN_DIR}:$PATH"
  - source variables.env
  script: 
    - |
      aws ssm put-parameter \
      --name "/app/${ENVIRONMENT}/app_version" \
      --region ${aws_region} \
      --value "${TAG}" \
      --type "String" \
      --overwrite

  artifacts:
    paths:
      - variables.env  
    reports:
      dotenv: variables.env 
  cache:
    key: "docker-aws-cli-cache"
    paths:
      - ${BIN_DIR}/  
    policy: pull-push  

update_asg:
  stage: update_asg
  needs: [app_version_to_parameter_store]
  before_script:
  - export PATH="${BIN_DIR}:$PATH"
  - source variables.env
  script: 
    - |

      # sed -i 's/\r$//' app/asg-config.txt  
      # set -o allexport  # Enable automatic exporting of variables
      # source app/asg-config.txt  # Load variables
      # set +o allexport  # Disable automatic exporting
      # cat app/asg-config.txt >> $GITHUB_ENV  # Append variables to GITHUB_ENV 
      aws autoscaling update-auto-scaling-group \
      --auto-scaling-group-name ${ENVIRONMENT}-app_asg \
      --min-size ${min_size} \
      --max-size ${max_size} \
      --desired-capacity ${desired_capacity}   


  artifacts:
    paths:
      - variables.env  
    reports:
      dotenv: variables.env 
  cache:
    key: "docker-aws-cli-cache"
    paths:
      - ${BIN_DIR}/  
    policy: pull-push  