workflow:
  rules:
    - if: '$CI_COMMIT_BRANCH != "master"'  # Exclude master branch
      # changes:
      #   - app/app_version.txt  # Trigger only if this file changes
      when: always
    - when: never  # Prevents the pipeline from running otherwise

stages:
  - setup
  - validate_version
  - load_env_variables
  - validate_existing_ECR_tags
  - build_and_push
  # - app_version_to_parameter_store
  # - update_asg


variables:
  BIN_DIR: "${CI_PROJECT_DIR}/bin"  # Store binaries in project directory
  DOCKER_HOST: tcp://docker:2375
  DOCKER_TLS_CERTDIR: ""

services:
  - docker:dind 


cache:
  key: "docker-aws-cli-cache"
  paths:
    - ${BIN_DIR}/  
  policy: pull-push


setup:
  image: docker:latest
  stage: setup
  before_script:
    - apt-get update && apt-get install -y unzip curl jq #docker.io  
    - mkdir -p ${BIN_DIR} && export PATH="${BIN_DIR}:$PATH"
    - if [ ! -f "${BIN_DIR}/aws" ]; then curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip" && unzip awscliv2.zip && ./aws/install --bin-dir ${BIN_DIR} --install-dir ${BIN_DIR}; fi
    # - 'curl -fsSL https://get.docker.com | bash'
    # #- systemctl status docker
    # - systemctl start docker
    # - systemctl enable docker
    # - 'chmod 666 /var/run/docker.sock'
  script:
    - ls /usr/local/bin/
    - docker ps
    - docker --version
  cache:
    key: "docker-aws-cli-cache"
    paths:
      - ${BIN_DIR}/  
    policy: pull-push  # Save & restore cache across jobs


validate_version:
  stage: validate_version
  needs: [setup]
  before_script:
  - export PATH="${BIN_DIR}:$PATH"
  script:
    - 'export VERSION=$(cat app/app_version.txt)'
    - 'echo "VERSION: $VERSION"'
    - 'TAG="${CI_COMMIT_REF_NAME}-app-v${VERSION}"'
    - 'echo ${TAG}'
    - 'git fetch --tags'
    - 'git tag'
    - > 
      if ! git fetch --tags || ! git tag | grep -q "^${TAG}$"; then 
        echo "Error: No matching tag ${TAG} found." && exit 1;  
      fi
    - 'echo "TAG=${TAG}" >> variables.env'
    - 'echo "VERSION=${VERSION}" >> variables.env'
    - 'echo "ENVIRONMENT=${CI_COMMIT_REF_NAME}" >> variables.env'

  artifacts:
    paths:
    - variables.env  # Ensure `variables.env` persis
    reports:
      dotenv: variables.env 
  cache:
    key: "docker-aws-cli-cache"
    paths:
      - ${BIN_DIR}/  
    policy: pull-push  

load_env_variables:
  stage: load_env_variables
  needs: [validate_version]
  before_script:
  - export PATH="${BIN_DIR}:$PATH"
  - source variables.env  # Load persisted variable
  script:
    - 'ENVIRONMENT_UPPERCASE=$(echo "${ENVIRONMENT}" | tr "[:lower:]" "[:upper:]")'
    - 'grep "^${ENVIRONMENT_UPPERCASE}_" app/.env | sed -E "s/^${ENVIRONMENT_UPPERCASE}_//" >> variables.env'
    - 'echo "ENVIRONMENT_UPPERCASE: ${ENVIRONMENT_UPPERCASE}"'
    - 'echo "ENVIRONMENT: ${ENVIRONMENT}"'
    - 'echo "TAG: ${TAG}"'

  artifacts:
    paths:
      - variables.env  
    reports:
      dotenv: variables.env 
  cache:
    key: "docker-aws-cli-cache"
    paths:
      - ${BIN_DIR}/  
    policy: pull-push  

validate_existing_ECR_tags:
  stage: validate_existing_ECR_tags
  needs: [load_env_variables]
  before_script:
  - export PATH="${BIN_DIR}:$PATH"
  - source variables.env
  script:
    - env
    - 'echo TAG on second stage: ${TAG}'
    - ls -lah
    - 'echo "AWS Region: ${aws_region}"'
    - |
      ECR_REPO_NAME=$(aws ssm get-parameter --region "${aws_region}" \
        --name "/app/${ENVIRONMENT}/ecr_repository_name" \
        --query "Parameter.Value" --output text 2>/dev/null || echo "ParameterNotFound")
      
      if [[ "${ECR_REPO_NAME}" == "ParameterNotFound" ]]; then
        echo "No ECR registry for the app has been created yet. Parameter /app/${ENVIRONMENT}/ecr_repository_name doesn't exist: ${ECR_REPO_NAME}"
        echo "Pipeline ends here since no ECR registry was found"
      else
        tags=$(aws ecr list-images --region ${aws_region} --repository-name ${ECR_REPO_NAME} --query 'imageIds[].imageTag' --output json)
        echo "Checking if the app version exists in the registry ${ECR_REPO_NAME}"

        if echo "${tags}" | jq -e --arg VERSION "${VERSION}" '.[] | select(. == "${VERSION}")' >/dev/null; then
            tag_exists=true
            echo "the tag ${TAG} exists in the registry ${ECR_REPO_NAME}"
            
        else
            tag_exists=false
            echo "the tag ${TAG} does not exist in the registry ${ECR_REPO_NAME}"
        fi

        echo "${tag_exists}"

      fi

      echo "The tag_exists value is: ${tag_exists}"
    
    - 'echo "ECR_REPO_NAME=${ECR_REPO_NAME}" >> variables.env'
    - 'echo "tag_exists=${tag_exists}" >> variables.env'

  artifacts:
    paths:
      - variables.env  
    reports:
      dotenv: variables.env 
  cache:
    key: "docker-aws-cli-cache"
    paths:
      - ${BIN_DIR}/  
    policy: pull-push  


build_and_push:
  image: docker:latest
  stage: build_and_push
  needs: [validate_existing_ECR_tags]
  rules:
    - exists:
        - version.env
    - if: '$tag_exists == "false"'
  before_script:
  - export PATH="${BIN_DIR}:$PATH"
  - source variables.env
  script:
    - 'aws ecr get-login-password --region ${aws_region} | docker login --username AWS --password-stdin $(aws sts get-caller-identity --query Account --output text).dkr.ecr.${aws_region}.amazonaws.com'
    - 'ECR_REGISTRY="$(aws sts get-caller-identity --query Account --output text).dkr.ecr.${aws_region}.amazonaws.com"'
    - 'git fetch --tags'
    - 'git checkout ${TAG}'
    - cd app/src/
    - 'docker build -t ${ECR_REPO_NAME}:${VERSION} .'
    - 'docker tag ${ECR_REPO_NAME}:${VERSION} ${ECR_REGISTRY}/${ECR_REPO_NAME}:${VERSION}'
    - 'docker push ${ECR_REGISTRY}/${ECR_REPO_NAME}:${VERSION}'
    


  artifacts:
    paths:
      - variables.env  
    reports:
      dotenv: variables.env 
  cache:
    key: "docker-aws-cli-cache"
    paths:
      - ${BIN_DIR}/  
    policy: pull-push  

